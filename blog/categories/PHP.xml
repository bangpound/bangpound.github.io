<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[!&amp;#]]></title>
    <link href="/blog/categories/PHP.xml" rel="self"/>
    <link href="/"/>
    <updated>2015-06-26T14:25:01-05:00</updated>
    <id>/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Guzzle 6 Logging with Symfony: what&#039;s the right way to create a callback service?]]></title>
            <link href="/blog/2015/06/25/guzzle-6-logging-with-symfony-whats-the-right-way-to-create-a-callback-service"/>
            <updated>2015-06-25T00:00:00-05:00</updated>
            <id>/blog/2015/06/25/guzzle-6-logging-with-symfony-whats-the-right-way-to-create-a-callback-service</id>
            <content type="html"><![CDATA[<p>The <a href="https://github.com/guzzle/guzzle/releases/tag/6.0.0">latest version of Guzzle</a> uses PSR-7. Functionality that
previously was based on events is now implemented as middleware. The <a href="https://github.com/guzzle/log-subscriber">log subscriber</a>
is not supported, and the logging middleware is part of the main Guzzle package.</p>

<p>This is how I implemented a Guzzle service with logging with Symfony's container.</p>

<pre><code class="language-yaml">parameters:
    guzzle.class: GuzzleHttp\Client
    guzzle.stack.class: GuzzleHttp\HandlerStack
    guzzle.middleware.class: GuzzleHttp\Middleware
    guzzle.message_formatter.class: GuzzleHttp\MessageFormatter

services:
    guzzle:
        class: %guzzle.class%
        arguments:
            -
                stack: @guzzle.stack

    guzzle.stack:
        public: false
        class: %guzzle.stack.class%
        factory: [ %guzzle.stack.class%, create ]
        calls:
            - [ push, [ @guzzle.logger ] ]

    guzzle.message_formatter:
        public: false
        class: %guzzle.message_formatter.class%

    guzzle.logger:
        public: false
        class: callback
        arguments: [@logger, @guzzle.message_formatter]
        factory: [GuzzleHttp\Middleware, log]
</code></pre>

<p>On the <code>guzzle.logger</code> service, the <code>callback</code> class is actually invalid, but without a class, it complains:</p>

<blockquote>
<p>[Symfony\Component\DependencyInjection\Exception\RuntimeException] Please add the class to service &quot;guzzle.logger&quot; even if it is constructed by a factory since we might need to add method calls based on compile-time checks.</p>
</blockquote>

<p>Nonetheless, when the dependencies are not public, Symfony compiles the Guzzle client service with a logger correctly.</p>

<pre><code class="language-php">&lt;?php

use Symfony\Component\DependencyInjection\Container;

class appDevDebugProjectContainer extends Container
{
    protected function getGuzzleService()
    {
        $a = \GuzzleHttp\HandlerStack::create();
        $a-&gt;push(\GuzzleHttp\Middleware::log(
            $this-&gt;get('logger'),
            new \GuzzleHttp\MessageFormatter()
        ));

        return $this-&gt;services['guzzle'] = new \GuzzleHttp\Client(array(
            'stack' =&gt; $a
        ));
    }
}
</code></pre>

<p>Given that Symfony services must be objects with classes, what is the right way to create a service with callbacks
without using a factory? The trick is to create the service without a factory, because if the service is
constructed entirely within the container, it could be configured or extended with container extensions and compiler
passes.</p>
]]></content>
        </entry>
    </feed>